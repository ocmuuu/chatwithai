import http from '@ohos.net.http';
import { SettingsInit } from '../setups/SettingsInit';
import { ChatMessage } from '../models/ChatModels';
import PreferencesUtil from '../utils/PreferencesUtil';

/**
 * å¹³å°ä¿¡æ¯æ¥å£
 */
interface PlatformInfo {
  name: string;
  website: string;
  description: string;
}

/**
 * AIå¹³å°é…ç½®æ¥å£
 */
interface AIConfig {
  apiKey: string;
  baseUrl: string;
}

/**
 * AI API è¯·æ±‚æ¥å£
 */
export interface AIRequest {
  messages: AIMessage[];
  model: string;
  temperature?: number;
  max_tokens?: number;
  stream?: boolean;
}

/**
 * AI æ¶ˆæ¯æ¥å£
 */
export interface AIMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

/**
 * AI API å“åº”æ¥å£
 */
export interface AIResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: AIChoice[];
  usage?: AIUsage;
}

/**
 * AI é€‰æ‹©æ¥å£
 */
export interface AIChoice {
  index: number;
  message: AIMessage;
  finish_reason: string;
}

/**
 * AI ä½¿ç”¨ç»Ÿè®¡æ¥å£
 */
export interface AIUsage {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
}

/**
 * AI é”™è¯¯è¯¦æƒ…æ¥å£
 */
export interface AIErrorDetail {
  message: string;
  type: string;
  code?: string;
}

/**
 * AI é”™è¯¯å“åº”æ¥å£
 */
export interface AIError {
  error: AIErrorDetail;
}

/**
 * AI æœåŠ¡ç±»
 */
export class AIService {
  private static instance: AIService;
  private context: Context | null = null;

  // æ–°å¢ï¼šå½“å‰AIå¹³å°å’Œæ¨¡å‹
  private currentProvider: string = 'deepseek';
  private currentModel: string = 'deepseek-chat';

  public getCurrentProvider(): string {
    return this.currentProvider;
  }

  public getCurrentModel(): string {
    return this.currentModel;
  }

  public setCurrentProvider(provider: string): void {
    this.currentProvider = provider;
    console.info(`åˆ‡æ¢åˆ°å¹³å°: ${provider}`);
  }

  /**
   * æ£€æŸ¥å½“å‰å¹³å°æ˜¯å¦å¯ç”¨ï¼ˆå·²é…ç½®APIå¯†é’¥ï¼‰
   */
  public async isCurrentProviderAvailable(): Promise<boolean> {
    return await this.checkApiKeyConfigured(this.currentProvider);
  }

  public setCurrentModel(model: string): void {
    this.currentModel = model;
    console.info(`åˆ‡æ¢åˆ°æ¨¡å‹: ${model}`);
  }

  /**
   * æ ¹æ®å¹³å°è·å–APIä¸»æœºåœ°å€
   */
  private getApiHostForProvider(provider: string): string {
    switch (provider) {
      case 'deepseek':
        return 'https://api.deepseek.com';
      case 'openai':
        return 'https://api.openai.com';
      case 'claude':
        return 'https://api.anthropic.com';
      case 'gemini':
        return 'https://generativelanguage.googleapis.com';
      case 'siliconflow':
        return 'https://api.siliconflow.cn';
      case 'volcengine':
        return 'https://ark.cn-beijing.volces.com';
      case 'xAI':
        return 'https://api.x.ai';
      case 'groq':
        return 'https://api.groq.com/openai';
      case 'chatglm-6b':
        return 'https://open.bigmodel.cn/api/paas/v4/';
      default:
        return 'https://api.deepseek.com'; // é»˜è®¤ä½¿ç”¨DeepSeek
    }
  }

  /**
   * æ£€æŸ¥æŒ‡å®šå¹³å°æ˜¯å¦å·²é…ç½®APIå¯†é’¥
   */
  private async checkApiKeyConfigured(provider: string): Promise<boolean> {
    if (!this.context) {
      return false;
    }

    try {
      const apiKey = await PreferencesUtil.getApiKey(provider);
      return typeof apiKey === 'string' && apiKey.length > 0;
    } catch (error) {
      console.error(`æ£€æŸ¥ ${provider} APIå¯†é’¥é…ç½®å¤±è´¥:`, error);
      return false;
    }
  }

  /**
   * è·å–å¹³å°é…ç½®æç¤ºä¿¡æ¯
   */
  private getConfigurationMessage(provider: string): string {
    let info: PlatformInfo | null = null;
    
    // ä½¿ç”¨switchè¯­å¥ä»£æ›¿å¯¹è±¡å­—é¢é‡æ˜ å°„
    switch (provider) {
      case 'openai':
        info = {
          name: 'OpenAI',
          website: 'https://platform.openai.com/api-keys',
          description: 'GPTç³»åˆ—æ¨¡å‹çš„å®˜æ–¹æä¾›å•†ï¼ŒåŠŸèƒ½å¼ºå¤§ï¼Œæ”¯æŒå¤šç§ä»»åŠ¡'
        };
        break;
      case 'claude':
        info = {
          name: 'Anthropic Claude',
          website: 'https://console.anthropic.com',
          description: 'ç”±Anthropicå¼€å‘ï¼Œæ³¨é‡å®‰å…¨æ€§å’Œå¯æ§æ€§çš„AIåŠ©æ‰‹'
        };
        break;
      case 'gemini':
        info = {
          name: 'Google Gemini',
          website: 'https://makersuite.google.com/app/apikey',
          description: 'Googleå¼€å‘çš„å¤šæ¨¡æ€å¤§è¯­è¨€æ¨¡å‹ï¼Œæ”¯æŒæ–‡æœ¬å’Œè§†è§‰ç†è§£'
        };
        break;
      case 'siliconflow':
        info = {
          name: 'SiliconFlow',
          website: 'https://cloud.siliconflow.cn',
          description: 'æä¾›å¤šç§å¼€æºæ¨¡å‹çš„é«˜æ€§èƒ½AIæœåŠ¡å¹³å°'
        };
        break;
      case 'volcengine':
        info = {
          name: 'ç«å±±å¼•æ“',
          website: 'https://www.volcengine.com/product/ark',
          description: 'å­—èŠ‚è·³åŠ¨æ——ä¸‹çš„AIæœåŠ¡å¹³å°ï¼Œæä¾›è±†åŒ…ç­‰æ¨¡å‹'
        };
        break;
      case 'xAI':
        info = {
          name: 'xAI Grok',
          website: 'https://console.x.ai',
          description: 'é©¬æ–¯å…‹åˆ›ç«‹çš„xAIå…¬å¸å¼€å‘çš„Grokç³»åˆ—æ¨¡å‹'
        };
        break;
      case 'groq':
        info = {
          name: 'Groq',
          website: 'https://console.groq.com/keys',
          description: 'ä¸“æ³¨äºé«˜é€ŸAIæ¨ç†çš„æœåŠ¡å¹³å°'
        };
        break;
      case 'chatglm-6b':
        info = {
          name: 'ChatGLM',
          website: 'https://open.bigmodel.cn',
          description: 'æ¸…åå¤§å­¦å’Œæ™ºè°±AIå¼€å‘çš„ä¸­æ–‡ä¼˜åŒ–å¤§è¯­è¨€æ¨¡å‹'
        };
        break;
      default:
        break;
    }

    if (!info) {
      return `â— éœ€è¦é…ç½® ${provider} API å¯†é’¥\n\nè¯·å…ˆåœ¨åº”ç”¨è®¾ç½®ä¸­é…ç½®ç›¸åº”çš„APIå¯†é’¥ã€‚`;
    }
    
    return `ğŸ” éœ€è¦é…ç½® ${info.name} API å¯†é’¥

**å…³äº ${info.name}ï¼š**
${info.description}

**é…ç½®æ­¥éª¤ï¼š**
1. ğŸ“± è®¿é—® ${info.name} å®˜ç½‘: ${info.website}
2. ğŸ”‘ åˆ›å»ºè´¦æˆ·å¹¶è·å–APIå¯†é’¥
3. âš™ï¸ åœ¨æœ¬åº”ç”¨è®¾ç½®ä¸­é…ç½®APIå¯†é’¥
4. âœ… é…ç½®å®Œæˆåå³å¯ä½¿ç”¨ ${info.name} çš„æ‰€æœ‰æ¨¡å‹

**ä¸´æ—¶æ–¹æ¡ˆï¼š**
å¦‚éœ€ç«‹å³ä½“éªŒAIå¯¹è¯ï¼Œå»ºè®®åˆ‡æ¢åˆ°å·²é…ç½®çš„ **DeepSeek** å¹³å°ï¼Œè¯¥å¹³å°æä¾›ä¼˜è´¨çš„AIæœåŠ¡ã€‚

---
ğŸ’¡ æç¤ºï¼šæ¯ä¸ªå¹³å°éƒ½æœ‰å…¶ç‹¬ç‰¹çš„ä¼˜åŠ¿ï¼Œé…ç½®å¤šä¸ªå¹³å°å¯ä»¥ä½“éªŒä¸åŒæ¨¡å‹çš„ç‰¹è‰²åŠŸèƒ½ã€‚`;
  }

  private constructor() {}

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): AIService {
    if (!AIService.instance) {
      AIService.instance = new AIService();
    }
    return AIService.instance;
  }

  /**
   * åˆå§‹åŒ–æœåŠ¡
   */
  public async initialize(context: Context): Promise<void> {
    this.context = context;
  }

  /**
   * å‘é€æ¶ˆæ¯åˆ° AI API
   */
  public async sendMessage(
    messages: ChatMessage[], 
    userMessage: string
  ): Promise<string> {
    if (!this.context) {
      throw new Error('AI æœåŠ¡æœªåˆå§‹åŒ–');
    }

    // é¦–å…ˆæ£€æŸ¥å½“å‰å¹³å°æ˜¯å¦å·²é…ç½®APIå¯†é’¥
    const isConfigured = await this.checkApiKeyConfigured(this.currentProvider);
    if (!isConfigured) {
      console.info(`${this.currentProvider} å¹³å°æœªé…ç½®APIå¯†é’¥ï¼Œè¿”å›é…ç½®æç¤º`);
      return this.getConfigurationMessage(this.currentProvider);
    }

    try {
      // è·å–å½“å‰å¹³å°çš„é…ç½®
      const apiKey = await PreferencesUtil.getApiKey(this.currentProvider);
      const apiUrl = await PreferencesUtil.getApiUrl(this.currentProvider);
      
      if (typeof apiKey !== 'string' || apiKey.length === 0) {
        throw new Error(`${this.currentProvider} æœªé…ç½® API Key`);
      }
      
      const baseUrl = typeof apiUrl === 'string' && apiUrl.length > 0 
        ? apiUrl 
        : this.getApiHostForProvider(this.currentProvider);
      
      const config: AIConfig = {
        apiKey: apiKey,
        baseUrl: baseUrl
      };

      // è·å–åº”ç”¨è®¾ç½®
      const settings = await SettingsInit.loadSettings(this.context);

      // æ„å»º API è¯·æ±‚æ¶ˆæ¯åˆ—è¡¨
      const apiMessages = this.buildAPIMessages(messages, userMessage, settings.maxContextMessages);

      // æ„å»ºè¯·æ±‚ä½“
      const requestBody: AIRequest = {
        model: this.currentModel, // ä½¿ç”¨ç”¨æˆ·é€‰æ‹©çš„æ¨¡å‹
        messages: apiMessages,
        temperature: settings.temperature,
        max_tokens: settings.maxTokens,
        stream: false
      };

      console.info(`å‘é€ ${this.currentProvider} API è¯·æ±‚:`, JSON.stringify(requestBody, null, 2));

      // å‘é€ HTTP è¯·æ±‚
      const response = await this.makeHTTPRequest(config, requestBody);
      
      // è§£æå“åº”
      const aiResponse = this.parseResponse(response);
      
      console.info('æ”¶åˆ° DeepSeek API å“åº”:', JSON.stringify(aiResponse, null, 2));

      // æå–å›å¤å†…å®¹
      if (aiResponse.choices && aiResponse.choices.length > 0) {
        const content = aiResponse.choices[0].message.content;
        return content || 'æŠ±æ­‰ï¼Œæˆ‘æ— æ³•ç”Ÿæˆå›å¤ã€‚';
      } else {
        throw new Error('API å“åº”æ ¼å¼é”™è¯¯');
      }

    } catch (error) {
      console.error('AI æœåŠ¡è°ƒç”¨å¤±è´¥:', error);
      
      if (error.message) {
        throw new Error(`AI æœåŠ¡è°ƒç”¨å¤±è´¥: ${error.message}`);
      } else {
        throw new Error('AI æœåŠ¡è°ƒç”¨å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * æ„å»º API æ¶ˆæ¯åˆ—è¡¨
   */
  private buildAPIMessages(
    messages: ChatMessage[], 
    userMessage: string, 
    maxContextMessages: number
  ): AIMessage[] {
    const apiMessages: AIMessage[] = [];

    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
    apiMessages.push({
      role: 'system',
      content: 'ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½åŠ©æ‰‹ï¼Œè¯·ç”¨ä¸­æ–‡å›å¤ç”¨æˆ·çš„é—®é¢˜ã€‚ä½ å¯ä»¥å¸®åŠ©ç”¨æˆ·è§£ç­”é—®é¢˜ã€æä¾›å»ºè®®ã€è¿›è¡Œå¯¹è¯ç­‰ã€‚è¯·åœ¨å›å¤ä¸­é€‚å½“ä½¿ç”¨ Markdown æ ¼å¼æ¥æé«˜å¯è¯»æ€§ï¼Œä¾‹å¦‚ä½¿ç”¨ **ç²—ä½“**ã€*æ–œä½“*ã€`ä»£ç `ã€## æ ‡é¢˜ å’Œ > å¼•ç”¨ ç­‰æ ¼å¼ã€‚'
    });

    // è·å–æœ€è¿‘çš„æ¶ˆæ¯ä½œä¸ºä¸Šä¸‹æ–‡
    const recentMessages = messages.slice(-maxContextMessages);
    
    // æ·»åŠ å†å²æ¶ˆæ¯åˆ°ä¸Šä¸‹æ–‡
    for (const message of recentMessages) {
      if (message.role === 'user' || message.role === 'assistant') {
        apiMessages.push({
          role: message.role,
          content: message.content
        });
      }
    }

    // æ·»åŠ å½“å‰ç”¨æˆ·æ¶ˆæ¯
    apiMessages.push({
      role: 'user',
      content: userMessage
    });

    return apiMessages;
  }

  /**
   * å‘é€ HTTP è¯·æ±‚
   */
  private async makeHTTPRequest(config: AIConfig, requestBody: AIRequest): Promise<string> {
    return new Promise((resolve, reject) => {
      const httpRequest = http.createHttp();
      
      const url = `${config.baseUrl}/chat/completions`;
      
      const options: http.HttpRequestOptions = {
        method: http.RequestMethod.POST,
        header: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${config.apiKey}`,
          'User-Agent': 'ChatWithAI/1.0.0'
        },
        extraData: JSON.stringify(requestBody),
        expectDataType: http.HttpDataType.STRING,
        usingCache: false,
        priority: 1,
        connectTimeout: 30000,
        readTimeout: 60000
      };

      httpRequest.request(url, options, (err, data) => {
        if (err) {
          console.error('HTTP è¯·æ±‚å¤±è´¥:', err);
          httpRequest.destroy();
          reject(new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${err.message || 'æœªçŸ¥é”™è¯¯'}`));
          return;
        }

        if (data.responseCode !== 200) {
          console.error('HTTP å“åº”çŠ¶æ€ç é”™è¯¯:', data.responseCode);
          console.error('å“åº”å†…å®¹:', data.result);
          httpRequest.destroy();
          
          // å°è¯•è§£æé”™è¯¯ä¿¡æ¯
          try {
            if (typeof data.result === 'string') {
              const errorResponse: AIError = JSON.parse(data.result);
              reject(new Error(`API é”™è¯¯ (${data.responseCode}): ${errorResponse.error.message}`));
            } else {
              reject(new Error(`HTTP é”™è¯¯: ${data.responseCode}`));
            }
          } catch (parseError) {
            reject(new Error(`HTTP é”™è¯¯: ${data.responseCode}`));
          }
          return;
        }

        httpRequest.destroy();
        resolve(data.result as string);
      });
    });
  }

  /**
   * è§£æ API å“åº”
   */
  private parseResponse(responseText: string): AIResponse {
    try {
      const response: AIResponse = JSON.parse(responseText);
      
      if (!response.choices || response.choices.length === 0) {
        throw new Error('API å“åº”ä¸­æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„å›å¤');
      }

      return response;
    } catch (error) {
      console.error('è§£æ API å“åº”å¤±è´¥:', error);
      console.error('åŸå§‹å“åº”:', responseText);
      throw new Error('API å“åº”æ ¼å¼é”™è¯¯');
    }
  }

  /**
   * æµ‹è¯• API è¿æ¥
   */
  public async testConnection(): Promise<boolean> {
    if (!this.context) {
      return false;
    }

    try {
      const testMessage = await this.sendMessage([], 'ä½ å¥½');
      return testMessage.length > 0;
    } catch (error) {
      console.error('API è¿æ¥æµ‹è¯•å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * æ ¹æ®é¦–è½®å¯¹è¯å†…å®¹è‡ªåŠ¨ç”Ÿæˆ10~20å­—çš„ä¸­æ–‡æ ‡é¢˜
   */
  public async generateTitle(userMessage: string, aiReply: string): Promise<string> {
    if (!this.context) {
      return userMessage.slice(0, 20);
    }

    // è‹¥å½“å‰å¹³å°æœªé…ç½® API Key åˆ™é™çº§ä½¿ç”¨æˆªå–å†…å®¹
    const isConfigured = await this.checkApiKeyConfigured(this.currentProvider);
    if (!isConfigured) {
      return userMessage.slice(0, 20);
    }

    try {
      const apiKey = await PreferencesUtil.getApiKey(this.currentProvider);
      const apiUrl = await PreferencesUtil.getApiUrl(this.currentProvider);
      const baseUrl = (apiUrl && apiUrl.length > 0) ? apiUrl : this.getApiHostForProvider(this.currentProvider);

      const config: AIConfig = { apiKey: apiKey!, baseUrl };

      // æ„é€ ç”¨äºç”Ÿæˆæ ‡é¢˜çš„å¯¹è¯ä¸Šä¸‹æ–‡
      const apiMessages: AIMessage[] = [
        {
          role: 'system',
          content: 'ä½ æ˜¯ä¸€ä¸ªæ ‡é¢˜ç”Ÿæˆå™¨ï¼Œè¯·æ ¹æ®ä¸‹é¢çš„å¯¹è¯å†…å®¹ç”Ÿæˆä¸€ä¸ª10åˆ°20å­—çš„ä¸­æ–‡æ ‡é¢˜ï¼Œç”¨äºæ¦‚æ‹¬å¯¹è¯ä¸»é¢˜ï¼Œä¸ä½¿ç”¨å¼•å·æˆ–å¤šä½™æ ‡ç‚¹ï¼Œåªè¿”å›æ ‡é¢˜æœ¬èº«ã€‚'
        },
        { role: 'user', content: userMessage },
        { role: 'assistant', content: aiReply }
      ];

      const requestBody: AIRequest = {
        model: this.currentModel,
        messages: apiMessages,
        temperature: 0.3,
        max_tokens: 20,
        stream: false
      };

      const responseText = await this.makeHTTPRequest(config, requestBody);
      const aiResponse = this.parseResponse(responseText);

      if (aiResponse.choices && aiResponse.choices.length > 0) {
        let title = aiResponse.choices[0].message.content.trim();
        // æ¸…ç†å¯èƒ½çš„å¼•å·å’Œå¥å·ï¼Œå¹¶é™åˆ¶é•¿åº¦
        title = title.replace(/["'â€œâ€â€˜â€™]/g, '').replace(/[ã€‚!?ï¼ï¼Ÿ]/g, '').slice(0, 20);
        return title;
      }

      return userMessage.slice(0, 20);
    } catch (error) {
      console.error('ç”Ÿæˆæ ‡é¢˜å¤±è´¥:', error);
      return userMessage.slice(0, 20);
    }
  }
} 